#!/usr/bin/python
import os
import sys
import time
#from readscale import *
from sendReading import *
import MySQLdb as mdb
from time import localtime, strftime
import os.path

con = None
debug = None

## connect to the database
con = mdb.connect('localhost', 'coffeeuser', 'coffee16', 'coffeedb');
cur = con.cursor(mdb.cursors.DictCursor)
#get the scale serial numbers and ids from the database
cur.execute("select id,serialno from scales")
scalerows = cur.fetchall()
serialnos={}
weights={}
for scale in scalerows:
	serialnos[scale["serialno"]]=scale["id"] 
	weights[str(scale["id"])] = 0

cur.close()

VENDOR_ID = 0x0922
PRODUCT_ID = 0x8004
DATA_MODE_GRAMS = 2
DATA_MODE_OUNCES = 11

# find the USB Dymo scale devices
devices = usb.core.find(find_all=True, idVendor=VENDOR_ID)

while 1:
	for s, i in serialnos.items():		
		serialno=str(s)
		id=str(i)
		if debug: print
		##time.sleep(.5) # please only one reading per second
		## read the live scale value
## read loop
		for device in devices:		
			devbus = str(device.bus)
			devaddr = str(device.address)
			productid=str(device.idProduct)
			
			if str(usb.util.get_string(device,256,3)) == serialno:
				if debug: print "scale id:" + id + " serial: "+ serialno
				if debug: print ("device serial:    <" + str(usb.util.get_string(device,256,3))) + ">"
#				try:
#					device.detach_kernel_driver(0)
#				except Exception, e:
#					pass # already unregistered

				# use the first/default configuration
#				device.set_configuration()

				# first endpoint
				endpoint = device[0][(0,0)][0]

				# read a data packet
				attempts = 10
				data = None
				while data is None and attempts > 0:
					try:
						data = device.read(endpoint.bEndpointAddress,
									   endpoint.wMaxPacketSize)
					except usb.core.USBError as e:
						data = None
						if e.args == ('Operation timed out',):
							attempts -= 1
							continue
				
				# The raw scale array data
				#print data
				raw_weight = data[4] + (256 * data[5])

				if data[2] == DATA_MODE_OUNCES:
					ounces = raw_weight * 0.1
					weight = "%s oz" % ounces
				elif data[2] == DATA_MODE_GRAMS:
					grams = raw_weight
					weight = "%s g" % grams
					
				reading = weight
				if debug: print "raw reading '" + reading +"'"
				readval = float(reading.split(" ")[0])
				readunit = reading.split(" ")[1]
				## if the units are ounces ("oz") then convert to "g"
				if readunit == "oz" and readval !=0:
					readval = readval*28.3495
					if debug: print "converted oz to g"
				if debug: print "current weight : '" + str(readval) +"' "+readunit
				if debug: print "current time   : "+strftime("%Y-%m-%d %H:%M:%S", localtime())
				
				## compare the cached value with the current value
				if readval != float(weights[id]):
					## if different then update the database and update the cache
					
					# determine the magnitude of the change here
					delta = abs(readval - float(weights[id]))
					
					# a small change of a few grams should not be noted
					if delta > 10: 
						# update it by sending the serial and weight to another program and not waiting for it to return..
						print serialno+" reading changed from "+str(weights[id])+" to "+str(readval)
						weights[id] = readval
						sendReading(id,weights[id])
					## if its a huge change, someone has pressed the handle
					if delta > 800:
						print "PRESS DETECTED"
				else:
					if debug: print "reading unchanged"
					# LONG TIME SINCE LAST READING?
	if debug: print ""
			
			
			